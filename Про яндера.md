![[Drawing 2024-10-29 05.13.11.excalidraw]]


`return;` Это досрочный выход из функции
# 1

`if (this.Teacher){<...>}` 

Вот такое часто встречается у начинающих кодеров, по факту тут идёт проверка на то, является ли объект учителем, и весь код если да внутри if, так можно делать когда кода мало, НО! лучше сделать проверку на то, что если объект НЕ учитель
```csharp
if (!this.Teacher){
return;
}

//А вот тут код, если всё таки учитель
```
так читаемость вырастет

# 2

`if (!this.WitnessedCorpse)` тут обратная ситуация, лучше сделать проверку на то, являетлся ли слабость какой-то там, те
```csharp
`if (this.WitnessedCorpse){
return;
}

//тут код если нет
```
так читаемость вырастет

# 3

Если мы хотим проверять изменение значения переменной, те. 
``` csharp
a = //строка с клавиатуры
switch (a){
	case "John":
		return 1;
		break;
	case "Mike":
		return 2;
		break;
	default:
		return 3;
}
```
Чтобы:
1. Улучшить читаемость
2. Писать меньше кода
3. Конструкция switch работает в разы быстрее чем if-else if-else

в его же случае
```csharp
switch (this.Witness){
	case "Weapon and Blood and ...":
		//код
		break;
	....
}
```

И лучше бы, делать это не строками а числами или неизменяемыми переменными, тк. шанс того, что ты сам наебёшься в коде, пока будешь прописывать эффект огромен, посуди сам, как проще
```
a = "Wearpoon and Bow and Knife and ..."
```
или
```
a = [1, 2, 3, 4, 5]
```

ну или если прям совсем память гавна и не помнишь что какой цифрой обозначил то
```
a = "WBK..." //по первой букве
```

В последних двух случаях порядок не имеет значения, а вот если ты например наебёшься в первом, то всё, пиздец всему. Но если например порядок реально важен, то вмето `[1, 2, 3, 4]` можно юзать `(1, 2, 3, 4)` разница в скобках но одно зависит от порядка, а другое нет(там где с круглыми и с квадратными соответственно)


![[Drawing 2024-10-29 05.27.58.excalidraw]]
# 1
Не надо оставлять пустые case в switch, это замедляет работу, если надо просто не забыть, то лучше использовать TODO List или на крайняк закомментить

``` csharp
// TODO
// 1. ...
// 2. ...
```

# 2 
Нет конечного элемента default в switch, это хоть и необязательно, но лучше его написать в такой конструкции
```csharp
swich (a){
	case 1:
		// code
		break;
	case 2:
		//code
		break;
	default:
		break;
}
```
то есть просто с break, но так, не будет вылезать лишних ошибок

>В начале разработки Yandere Simulator моей целью было быстро создать грубый прототип, который можно было бы использовать для продвижения игры на Kickstarter. Я хотел создать простой прототип, который позволил бы мне продемонстрировать запланированные функции и механики, которые должны были быть в финальной версии игры. В тот период я не беспокоился о написании эффективного или оптимизированного кода, потому что не планировал использовать его в финальной версии игры. Этот код был написан только для того, чтобы я мог продемонстрировать игровой процесс в видео на YouTube и на Kickstarter.

Код который он написал, можно было написать быстрее раза в 1.5-2 потому что его удобнее читать и ориентироваться в нём. а ещё из-за отсутствия лишних деталей

> Есть люди, которые утверждают, что «Yandere Simulator» имеет низкую частоту кадров из-за операторов «если-то-иначе». Однако операторы «если-то-иначе» на самом деле не оказывают существенного влияния на частоту кадров в игре. Компьютеры очень быстро перебирают списки. Это правда, что компьютер может перебирать список операторов switch быстрее, чем список операторов «если-то-иначе», **но разница составит менее миллисекунды. Этого недостаточно, чтобы повлиять на частоту кадров в игре.**

Во1, FPS может проседать из-за вычислений
Во2, разница длинной в ДЕСЯТКИ СЕКУНД а не менее миллисекунды, для списка из 2-3 элементов ок, <1 мс, если список хотя бы из 10-15 больших условий(2 -3 условия) то сильно больше и двух секунд, это решает

>Даже с учётом вышесказанного, есть ещё одна причина, по которой эти обвинения несостоятельны. Хотя в игре всё ещё есть несколько скриптов, в которых я использую длинную цепочку операторов else-if, **большинство этих скриптов работают только один кадр.** Скрипт, который работает только один кадр, а затем больше никогда не запускается, **не может повлиять на частоту кадров в игре.**

То что для нас один кадр, для машины занимает секунды вычислений, из-за чего один кадр для нас длится секунду или больше, из-за этого средний фрейм рейт снижается. А ещё, ебать, покажите мне скрипт, который за всю игру работает только 1 кадр. Это сука сюр блядь, ахахах, он подгружается игрой и нагружает вычислительные мощьности, дурак блядь. А ещё, не бывает почти таких скриптов, чтобы один кадр за всю игру нахуй

Далее привёл код, с 3 элементами, в таком случе конечно блядь разницы не будет, а ты слелай это нахуй с 3000 элементами. Увидишь разницу в 10 секунд и закрой ебало.

>Самый "тяжелый" скрипт в игре, StudentScript, занимает всего 2% времени процессора, и это только потому, что их одновременно запущено 88:**[https://i.imgur.com/gGjtav0.png](https://i.imgur.com/gGjtav0.png)**Правильно - **единственный скрипт, который использует больше всего инструкций else-if, должен выполняться 88 раз, чтобы добиться хотя бы 2% разницы.**

Я больше чем уверен в том, что этот скрипт занимал 2% времени, по 2 причинам
1. Он не активен и просто пассивно сжирает 2% времени, что ебать как плохо
2. Игра запущена либо слишком мало времени либо слишком много времени, на скрине не увидел, из-за чего скрипт либо отработал и занимает 2% времени(см. 1п) либо ещё не успел выполнится(см. 1п)

>Возможно, стоит упомянуть, что фраза «У Yandere Simulator низкая частота кадров!» стала мемом много лет назад, когда Yandere Simulator действительно _страдала_ от проблем с производительностью. Однако с тех пор игра претерпела множество оптимизаций и улучшений частоты кадров, и со временем этот мем становится всё менее и менее точным. В 2016 году можно было бы сказать, что даже мощный компьютер не мог запустить Yandere Simulator с приемлемой частотой кадров. Однако на том же компьютере без проблем должна работать сборка Yandere Sim 2024 года. (Вы можете скачать сборку 2016 года и сборку 2024 года и протестировать их самостоятельно, если не верите мне.)

Показывает чел, и на скрине выше видно, что даже у него 15 фпс...

![[Pasted image 20241029054659.png]]
Та же хуйня со свичем
И подгрузка материалов, как правило это дело отдельного класса ViewModel и писать надо так, чтобы там всё было оптимизированно.
А ещё, никого нахуй не напрягает, что блядь например, смотрим первый иф
Там материал 0 становится на мето девчачей юрл моделью, и следующей же строкой заменяется на 3 форму и так в каждом

Это могло возникнуть из-за многослойности одежды, НО, НО, какой нахуй смысл, например генерить трусы если сверху есть штаны... лишняя нагруженность



Далее я нашёл соурсную версию симулятора, разберу пару файлов

![[Pasted image 20241029055202.png]]
просто пустой класс, почему бы и нет

![[Pasted image 20241029055303.png]]
Нахера мы сначала присваем координаты, потом меняем положение по х и снова присваем, если foreach отрабатывает достаточно быстро и это не то что видно не будет, а просто лишнее награмождение кода, ебаного
![[Pasted image 20241029055549.png]]
тоже самое

![[Pasted image 20241029055646.png]]
тоже прикол начинающего программиста, типо блядь, хахаах, нахуя. Значит смотри, видим что первая переменная объявлена в блоке иф, НО с припиской this.
Это значит, что переменная переменная создана ВО ВСЁМ КЛАССЕ при этом, он в коде 13 раз её переопределяет и делает равной 0, это бред полный, при том, что эта переменная используется только локально, в пределах одной функции, приписка this. не нужна, и может нахуй сломать код, при неосторожности

![[Pasted image 20241029055922.png]]
Чек на условия


![[Pasted image 20241029060052.png]]
Тоже прикол, 200 строк кода и ещё 17 конструкций иф вот в этой хуйне, лучше использовать то, о чём говорили вначале


Ещё:
файлы не распределены по папкам, и модели данных и классы описывающие логику, и вью модели всё в кучу.

Фильтры на камеру вообще нахуй можно было сделать просто одним классом сборником, а не делать 56 классов нахуй!

При этом есть файл CameraScript где вообще напихано всё что надо и не очень


Вывод: я слышал конечно что код гавна, но почекав просто ахуел. Я много чего скипнул конечно, прям совсем пиздец, такое можно получить только разбирая exe на скрипты, но всё равно, машинный код в исходный научились определять уже достаточно точно, а я вижу, что репозиторий обновлён всего пару месяцев назад и это ну полная пизда.